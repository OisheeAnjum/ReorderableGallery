{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useMeasure } from \"./use-measure\";\nimport { GridContext } from \"./GridContext\";\nimport { GridItem } from \"./GridItem\";\nimport swap from \"./swap\";\nimport { getPositionForIndex, getTargetIndex } from \"./helpers\";\nexport function GridDropZone(_a) {\n  var items = _a.items,\n    id = _a.id,\n    boxesPerRow = _a.boxesPerRow,\n    children = _a.children,\n    getKey = _a.getKey,\n    _b = _a.disableDrag,\n    disableDrag = _b === void 0 ? false : _b,\n    _c = _a.disableDrop,\n    disableDrop = _c === void 0 ? false : _c,\n    rowHeight = _a.rowHeight,\n    other = tslib_1.__rest(_a, [\"items\", \"id\", \"boxesPerRow\", \"children\", \"getKey\", \"disableDrag\", \"disableDrop\", \"rowHeight\"]);\n  var _d = React.useContext(GridContext),\n    traverse = _d.traverse,\n    startTraverse = _d.startTraverse,\n    endTraverse = _d.endTraverse,\n    register = _d.register,\n    onChange = _d.onChange,\n    remove = _d.remove,\n    getActiveDropId = _d.getActiveDropId;\n  var ref = React.useRef(null);\n  var bounds = useMeasure(ref).bounds;\n  var _e = tslib_1.__read(React.useState(null), 2),\n    draggingIndex = _e[0],\n    setDraggingIndex = _e[1];\n  var _f = tslib_1.__read(React.useState(null), 2),\n    placeholder = _f[0],\n    setPlaceholder = _f[1];\n  var traverseIndex = traverse && !traverse.execute && traverse.targetId === id ? traverse.targetIndex : null;\n  var grid = {\n    columnWidth: bounds.width / boxesPerRow,\n    boxesPerRow: boxesPerRow,\n    rowHeight: rowHeight\n  };\n  /**\n   * Register our dropzone with our grid context\n   */\n  React.useEffect(function () {\n    register(id, {\n      top: bounds.top,\n      bottom: bounds.bottom,\n      left: bounds.left,\n      right: bounds.right,\n      width: bounds.width,\n      height: bounds.height,\n      count: items.length,\n      grid: grid,\n      disableDrop: disableDrop\n    });\n  }, [items, disableDrop, bounds, id, grid]);\n  /**\n   * Unregister when unmounting\n   */\n  React.useEffect(function () {\n    return function () {\n      return remove(id);\n    };\n  }, [id]);\n  // keep an initial list of our item indexes. We use this\n  // when animating swap positions on drag events\n  var itemsIndexes = items.map(function (_, i) {\n    return i;\n  });\n  return React.createElement(\"div\", tslib_1.__assign({\n    ref: ref\n  }, other), grid.columnWidth === 0 ? null : items.map(function (item, i) {\n    var isTraverseTarget = traverse && traverse.targetId === id && traverse.targetIndex === i;\n    var order = placeholder ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex) : itemsIndexes;\n    var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);\n    /**\n     * Handle a child being dragged\n     * @param state\n     * @param x\n     * @param y\n     */\n    function onMove(state, x, y) {\n      if (draggingIndex !== i) {\n        setDraggingIndex(i);\n      }\n      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n      if (targetDropId && targetDropId !== id) {\n        startTraverse(id, targetDropId, x, y, i);\n      } else {\n        endTraverse();\n      }\n      var targetIndex = targetDropId !== id ? items.length : getTargetIndex(i, grid, items.length, state.delta[0], state.delta[1]);\n      if (targetIndex !== i) {\n        if (placeholder && placeholder.targetIndex !== targetIndex || !placeholder) {\n          setPlaceholder({\n            targetIndex: targetIndex,\n            startIndex: i\n          });\n        }\n      } else if (placeholder) {\n        setPlaceholder(null);\n      }\n    }\n    /**\n     * Handle drag end events\n     */\n    function onEnd(state, x, y) {\n      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n      var targetIndex = targetDropId !== id ? items.length : getTargetIndex(i, grid, items.length, state.delta[0], state.delta[1]);\n      // traverse?\n      if (traverse) {\n        onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);\n      } else {\n        onChange(id, i, targetIndex);\n      }\n      setPlaceholder(null);\n      setDraggingIndex(null);\n    }\n    return React.createElement(GridItem, {\n      key: getKey(item),\n      item: item,\n      top: pos.xy[1],\n      disableDrag: disableDrag,\n      endTraverse: endTraverse,\n      mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : undefined,\n      left: pos.xy[0],\n      i: i,\n      onMove: onMove,\n      onEnd: onEnd,\n      grid: grid,\n      dragging: i === draggingIndex\n    }, children);\n  }));\n}","map":{"version":3,"names":["tslib_1","React","useMeasure","GridContext","GridItem","swap","getPositionForIndex","getTargetIndex","GridDropZone","_a","items","id","boxesPerRow","children","getKey","_b","disableDrag","_c","disableDrop","rowHeight","other","__rest","_d","useContext","traverse","startTraverse","endTraverse","register","onChange","remove","getActiveDropId","ref","useRef","bounds","_e","__read","useState","draggingIndex","setDraggingIndex","_f","placeholder","setPlaceholder","traverseIndex","execute","targetId","targetIndex","grid","columnWidth","width","useEffect","top","bottom","left","right","height","count","length","itemsIndexes","map","_","i","createElement","__assign","item","isTraverseTarget","order","startIndex","pos","indexOf","onMove","state","x","y","targetDropId","delta","onEnd","sourceId","sourceIndex","key","xy","mountWithTraverseTarget","tx","ty","undefined","dragging"],"sources":["C:/Users/A/Desktop/gallery/node_modules/react-grid-dnd/esm/GridDropZone.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { useMeasure } from \"./use-measure\";\nimport { GridContext } from \"./GridContext\";\nimport { GridItem } from \"./GridItem\";\nimport swap from \"./swap\";\nimport { getPositionForIndex, getTargetIndex } from \"./helpers\";\nexport function GridDropZone(_a) {\n    var items = _a.items, id = _a.id, boxesPerRow = _a.boxesPerRow, children = _a.children, getKey = _a.getKey, _b = _a.disableDrag, disableDrag = _b === void 0 ? false : _b, _c = _a.disableDrop, disableDrop = _c === void 0 ? false : _c, rowHeight = _a.rowHeight, other = tslib_1.__rest(_a, [\"items\", \"id\", \"boxesPerRow\", \"children\", \"getKey\", \"disableDrag\", \"disableDrop\", \"rowHeight\"]);\n    var _d = React.useContext(GridContext), traverse = _d.traverse, startTraverse = _d.startTraverse, endTraverse = _d.endTraverse, register = _d.register, onChange = _d.onChange, remove = _d.remove, getActiveDropId = _d.getActiveDropId;\n    var ref = React.useRef(null);\n    var bounds = useMeasure(ref).bounds;\n    var _e = tslib_1.__read(React.useState(null), 2), draggingIndex = _e[0], setDraggingIndex = _e[1];\n    var _f = tslib_1.__read(React.useState(null), 2), placeholder = _f[0], setPlaceholder = _f[1];\n    var traverseIndex = traverse && !traverse.execute && traverse.targetId === id\n        ? traverse.targetIndex\n        : null;\n    var grid = {\n        columnWidth: bounds.width / boxesPerRow,\n        boxesPerRow: boxesPerRow,\n        rowHeight: rowHeight\n    };\n    /**\n     * Register our dropzone with our grid context\n     */\n    React.useEffect(function () {\n        register(id, {\n            top: bounds.top,\n            bottom: bounds.bottom,\n            left: bounds.left,\n            right: bounds.right,\n            width: bounds.width,\n            height: bounds.height,\n            count: items.length,\n            grid: grid,\n            disableDrop: disableDrop\n        });\n    }, [items, disableDrop, bounds, id, grid]);\n    /**\n     * Unregister when unmounting\n     */\n    React.useEffect(function () {\n        return function () { return remove(id); };\n    }, [id]);\n    // keep an initial list of our item indexes. We use this\n    // when animating swap positions on drag events\n    var itemsIndexes = items.map(function (_, i) { return i; });\n    return (React.createElement(\"div\", tslib_1.__assign({ ref: ref }, other), grid.columnWidth === 0\n        ? null\n        : items.map(function (item, i) {\n            var isTraverseTarget = traverse &&\n                traverse.targetId === id &&\n                traverse.targetIndex === i;\n            var order = placeholder\n                ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex)\n                : itemsIndexes;\n            var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);\n            /**\n             * Handle a child being dragged\n             * @param state\n             * @param x\n             * @param y\n             */\n            function onMove(state, x, y) {\n                if (draggingIndex !== i) {\n                    setDraggingIndex(i);\n                }\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n                if (targetDropId && targetDropId !== id) {\n                    startTraverse(id, targetDropId, x, y, i);\n                }\n                else {\n                    endTraverse();\n                }\n                var targetIndex = targetDropId !== id\n                    ? items.length\n                    : getTargetIndex(i, grid, items.length, state.delta[0], state.delta[1]);\n                if (targetIndex !== i) {\n                    if ((placeholder && placeholder.targetIndex !== targetIndex) ||\n                        !placeholder) {\n                        setPlaceholder({\n                            targetIndex: targetIndex,\n                            startIndex: i\n                        });\n                    }\n                }\n                else if (placeholder) {\n                    setPlaceholder(null);\n                }\n            }\n            /**\n             * Handle drag end events\n             */\n            function onEnd(state, x, y) {\n                var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);\n                var targetIndex = targetDropId !== id\n                    ? items.length\n                    : getTargetIndex(i, grid, items.length, state.delta[0], state.delta[1]);\n                // traverse?\n                if (traverse) {\n                    onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);\n                }\n                else {\n                    onChange(id, i, targetIndex);\n                }\n                setPlaceholder(null);\n                setDraggingIndex(null);\n            }\n            return (React.createElement(GridItem, { key: getKey(item), item: item, top: pos.xy[1], disableDrag: disableDrag, endTraverse: endTraverse, mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : undefined, left: pos.xy[0], i: i, onMove: onMove, onEnd: onEnd, grid: grid, dragging: i === draggingIndex }, children));\n        })));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}