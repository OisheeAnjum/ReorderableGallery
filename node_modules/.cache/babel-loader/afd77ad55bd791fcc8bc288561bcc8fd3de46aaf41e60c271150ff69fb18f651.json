{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\nvar noop = function () {\n  throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\nexport var GridContext = React.createContext({\n  register: noop,\n  remove: noop,\n  getActiveDropId: noop,\n  startTraverse: noop,\n  traverse: null,\n  endTraverse: noop,\n  onChange: noop\n});\nexport function GridContextProvider(_a) {\n  var children = _a.children,\n    onChange = _a.onChange;\n  var _b = tslib_1.__read(React.useState(null), 2),\n    traverse = _b[0],\n    setTraverse = _b[1];\n  var dropRefs = React.useRef(new Map());\n  /**\n   * Register a drop zone with relevant information\n   * @param id\n   * @param options\n   */\n  function register(id, options) {\n    dropRefs.current.set(id, options);\n  }\n  /**\n   * Remove a drop zone (typically on unmount)\n   * @param id\n   */\n  function remove(id) {\n    dropRefs.current.delete(id);\n  }\n  /**\n   * Determine the fixed position (pageX) of an item\n   * @param sourceId\n   * @param rx relative x\n   * @param ry relative y\n   */\n  function getFixedPosition(sourceId, rx, ry) {\n    var _a = dropRefs.current.get(sourceId),\n      left = _a.left,\n      top = _a.top;\n    return {\n      x: left + rx,\n      y: top + ry\n    };\n  }\n  /**\n   * Get a relative position for a target dropzone given\n   * a fixed position\n   * @param targetId\n   * @param fx fixed x\n   * @param fy fixed y\n   */\n  function getRelativePosition(targetId, fx, fy) {\n    var _a = dropRefs.current.get(targetId),\n      left = _a.left,\n      top = _a.top;\n    return {\n      x: fx - left,\n      y: fy - top\n    };\n  }\n  /**\n   * Determine the difference in coordinates between\n   * two dropzones\n   * @param sourceId\n   * @param targetId\n   */\n  function diffDropzones(sourceId, targetId) {\n    var sBounds = dropRefs.current.get(sourceId);\n    var tBounds = dropRefs.current.get(targetId);\n    return {\n      x: tBounds.left - sBounds.left,\n      y: tBounds.top - sBounds.top\n    };\n  }\n  /**\n   * Determine which dropzone we are actively dragging over\n   * @param sourceId\n   * @param x\n   * @param y\n   */\n  function getActiveDropId(sourceId, x, y) {\n    var e_1, _a;\n    var _b = getFixedPosition(sourceId, x, y),\n      fx = _b.x,\n      fy = _b.y;\n    try {\n      // probably faster just using an array for dropRefs\n      for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = tslib_1.__read(_d.value, 2),\n          key = _e[0],\n          bounds = _e[1];\n        if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {\n          return key;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return null;\n  }\n  /**\n   * Trigger a traversal (when one item is being dropped\n   * on a different dropzone)\n   * @param sourceId\n   * @param targetId\n   * @param x\n   * @param y\n   * @param sourceIndex\n   */\n  function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n    var _a = getFixedPosition(sourceId, x, y),\n      fx = _a.x,\n      fy = _a.y;\n    var _b = getRelativePosition(targetId, fx, fy),\n      rx = _b.x,\n      ry = _b.y;\n    var _c = dropRefs.current.get(targetId),\n      targetGrid = _c.grid,\n      count = _c.count;\n    var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n    var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2),\n      px = _d[0],\n      py = _d[1];\n    var _e = diffDropzones(sourceId, targetId),\n      dx = _e.x,\n      dy = _e.y;\n    // only update traverse if targetId or targetIndex have changed\n    if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {\n      setTraverse({\n        rx: px + dx,\n        ry: py + dy,\n        tx: rx,\n        ty: ry,\n        sourceId: sourceId,\n        targetId: targetId,\n        sourceIndex: sourceIndex,\n        targetIndex: targetIndex\n      });\n    }\n  }\n  /**\n   * End any active traversals\n   */\n  function endTraverse() {\n    setTraverse(null);\n  }\n  /**\n   * Perform a change to list item arrays.\n   * If it doesn't include targetId, it's a switch\n   * of order within the one array itself.\n   */\n  function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n    // this is a bit hacky, but seems to work for now. The idea\n    // is that we want our newly mounted traversed grid item\n    // to start its animation from the last target location.\n    // Execute informs our GridDropZone to remove the placeholder\n    // but to pass the initial location to the newly mounted\n    // grid item at the specified index.\n    // The problem here is that it's async, so potentially something\n    // could mount in its place in between setTraversal and onChange\n    // executing. Or maybe onChange won't do anything, in which case\n    // our state is kinda messed up.\n    // So it's sorta a controlled component, but not really, because\n    // if you don't do what we suggest, then it gets messed up.\n    // One solution is to bring the state in-component and force\n    // the state to be updated by us, since it's basically required\n    // anyway.\n    // We could possibly also use a unique identifier for the grid (besides\n    // the index). This could still result in weirdness, but would\n    // be more unlikely.\n    // Ultimately it's kinda messed because we are trying to do something\n    // imperative in a declarative interface.\n    setTraverse(tslib_1.__assign({}, traverse, {\n      execute: true\n    }));\n    onChange(sourceId, sourceIndex, targetIndex, targetId);\n  }\n  return React.createElement(GridContext.Provider, {\n    value: {\n      register: register,\n      remove: remove,\n      getActiveDropId: getActiveDropId,\n      startTraverse: startTraverse,\n      traverse: traverse,\n      endTraverse: endTraverse,\n      onChange: onSwitch\n    }\n  }, children);\n}","map":{"version":3,"names":["tslib_1","React","getPositionForIndex","getIndexFromCoordinates","noop","Error","GridContext","createContext","register","remove","getActiveDropId","startTraverse","traverse","endTraverse","onChange","GridContextProvider","_a","children","_b","__read","useState","setTraverse","dropRefs","useRef","Map","id","options","current","set","delete","getFixedPosition","sourceId","rx","ry","get","left","top","x","y","getRelativePosition","targetId","fx","fy","diffDropzones","sBounds","tBounds","e_1","_c","__values","entries","_d","next","done","_e","value","key","bounds","disableDrop","right","bottom","e_1_1","error","return","call","sourceIndex","targetGrid","grid","count","targetIndex","columnWidth","rowHeight","xy","px","py","dx","dy","tx","ty","onSwitch","__assign","execute","createElement","Provider"],"sources":["C:/Users/A/Desktop/gallery/node_modules/react-grid-dnd/esm/GridContext.js"],"sourcesContent":["import * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { getPositionForIndex, getIndexFromCoordinates } from \"./helpers\";\nvar noop = function () {\n    throw new Error(\"Make sure that you have wrapped your drop zones with GridContext\");\n};\nexport var GridContext = React.createContext({\n    register: noop,\n    remove: noop,\n    getActiveDropId: noop,\n    startTraverse: noop,\n    traverse: null,\n    endTraverse: noop,\n    onChange: noop\n});\nexport function GridContextProvider(_a) {\n    var children = _a.children, onChange = _a.onChange;\n    var _b = tslib_1.__read(React.useState(null), 2), traverse = _b[0], setTraverse = _b[1];\n    var dropRefs = React.useRef(new Map());\n    /**\n     * Register a drop zone with relevant information\n     * @param id\n     * @param options\n     */\n    function register(id, options) {\n        dropRefs.current.set(id, options);\n    }\n    /**\n     * Remove a drop zone (typically on unmount)\n     * @param id\n     */\n    function remove(id) {\n        dropRefs.current.delete(id);\n    }\n    /**\n     * Determine the fixed position (pageX) of an item\n     * @param sourceId\n     * @param rx relative x\n     * @param ry relative y\n     */\n    function getFixedPosition(sourceId, rx, ry) {\n        var _a = dropRefs.current.get(sourceId), left = _a.left, top = _a.top;\n        return {\n            x: left + rx,\n            y: top + ry\n        };\n    }\n    /**\n     * Get a relative position for a target dropzone given\n     * a fixed position\n     * @param targetId\n     * @param fx fixed x\n     * @param fy fixed y\n     */\n    function getRelativePosition(targetId, fx, fy) {\n        var _a = dropRefs.current.get(targetId), left = _a.left, top = _a.top;\n        return {\n            x: fx - left,\n            y: fy - top\n        };\n    }\n    /**\n     * Determine the difference in coordinates between\n     * two dropzones\n     * @param sourceId\n     * @param targetId\n     */\n    function diffDropzones(sourceId, targetId) {\n        var sBounds = dropRefs.current.get(sourceId);\n        var tBounds = dropRefs.current.get(targetId);\n        return {\n            x: tBounds.left - sBounds.left,\n            y: tBounds.top - sBounds.top\n        };\n    }\n    /**\n     * Determine which dropzone we are actively dragging over\n     * @param sourceId\n     * @param x\n     * @param y\n     */\n    function getActiveDropId(sourceId, x, y) {\n        var e_1, _a;\n        var _b = getFixedPosition(sourceId, x, y), fx = _b.x, fy = _b.y;\n        try {\n            // probably faster just using an array for dropRefs\n            for (var _c = tslib_1.__values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var _e = tslib_1.__read(_d.value, 2), key = _e[0], bounds = _e[1];\n                if (!bounds.disableDrop &&\n                    fx > bounds.left &&\n                    fx < bounds.right &&\n                    fy > bounds.top &&\n                    fy < bounds.bottom) {\n                    return key;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return null;\n    }\n    /**\n     * Trigger a traversal (when one item is being dropped\n     * on a different dropzone)\n     * @param sourceId\n     * @param targetId\n     * @param x\n     * @param y\n     * @param sourceIndex\n     */\n    function startTraverse(sourceId, targetId, x, y, sourceIndex) {\n        var _a = getFixedPosition(sourceId, x, y), fx = _a.x, fy = _a.y;\n        var _b = getRelativePosition(targetId, fx, fy), rx = _b.x, ry = _b.y;\n        var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;\n        var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);\n        var _d = tslib_1.__read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];\n        var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;\n        // only update traverse if targetId or targetIndex have changed\n        if (!traverse ||\n            !(traverse &&\n                traverse.targetIndex !== targetIndex &&\n                traverse.targetId !== targetId)) {\n            setTraverse({\n                rx: px + dx,\n                ry: py + dy,\n                tx: rx,\n                ty: ry,\n                sourceId: sourceId,\n                targetId: targetId,\n                sourceIndex: sourceIndex,\n                targetIndex: targetIndex\n            });\n        }\n    }\n    /**\n     * End any active traversals\n     */\n    function endTraverse() {\n        setTraverse(null);\n    }\n    /**\n     * Perform a change to list item arrays.\n     * If it doesn't include targetId, it's a switch\n     * of order within the one array itself.\n     */\n    function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {\n        // this is a bit hacky, but seems to work for now. The idea\n        // is that we want our newly mounted traversed grid item\n        // to start its animation from the last target location.\n        // Execute informs our GridDropZone to remove the placeholder\n        // but to pass the initial location to the newly mounted\n        // grid item at the specified index.\n        // The problem here is that it's async, so potentially something\n        // could mount in its place in between setTraversal and onChange\n        // executing. Or maybe onChange won't do anything, in which case\n        // our state is kinda messed up.\n        // So it's sorta a controlled component, but not really, because\n        // if you don't do what we suggest, then it gets messed up.\n        // One solution is to bring the state in-component and force\n        // the state to be updated by us, since it's basically required\n        // anyway.\n        // We could possibly also use a unique identifier for the grid (besides\n        // the index). This could still result in weirdness, but would\n        // be more unlikely.\n        // Ultimately it's kinda messed because we are trying to do something\n        // imperative in a declarative interface.\n        setTraverse(tslib_1.__assign({}, traverse, { execute: true }));\n        onChange(sourceId, sourceIndex, targetIndex, targetId);\n    }\n    return (React.createElement(GridContext.Provider, { value: {\n            register: register,\n            remove: remove,\n            getActiveDropId: getActiveDropId,\n            startTraverse: startTraverse,\n            traverse: traverse,\n            endTraverse: endTraverse,\n            onChange: onSwitch\n        } }, children));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}